Video presentation COMP 254 Data Structures and Algorithms Assignment 5 Using Trees and Priority Queues
Exercise 1 To design the algorithm and method inorder_next for a binary tree T, we need to consider 2 scenarios: Scenario 1: If node p has a right child, the next node in inorder traversal is the left most node in the right subtree Scenario 2: If node p doesn't have a right child, traverse up the tree until the left child of its parent is found
By defining a list to tree function and apply it to the list of number from one to seven, we can print the inorder traversal. By applying inorder_next we could see that The next node of 4 is 2 the next node of 2 is 5 the next node of 5 is 1 the next node of 1 is 6 the next node of 6 is 3 the next node of 3 is 7 and the next node of 7 is None.
To design the algorithm and method postorder_next for a binary tree T, we need to consider 3 scenarios: Senario 1: If node p is the root, there is no next node in postorder traversal Senario 2: If node p is the left child and the parent has a right child, the next node in the postorder traversal is the leftmost leaf node in the parent's right subtree Senario 3: If p is the right child or if the parent has no right child, the next node in the postorder traversal is the parent.
By using the list to tree function and apply it to the list of number from one to seven, we can print the postorder traversal. By applying postorder_next, we could see that the next node of 4 is 5 the next node of 5 is 2 the next node of 2 is 6 the next node of 6 is 7 the next node of 7 is 3 the next node of 3 is 1 and the next node of 1 is None
Exercise 2 To design an efficient algorithm that computes and prints, for every position p of a tree T, the element of p followed by the height of pâ€™s subtree, we could first define postorder_height function to return the height of the node p: "First, we'll initialize the height for the current node. Then, we'll loop through all the children of the current node. For each child, we'll take the maximum height of its children and add one to account for the edge. After computing the height for the current node, we'll print the element of the node along with its computed height and return this height. After setting up this process, we can use the function postorder_height to compute the heights starting from the root of the tree."
By using the list to tree and print draw_tree functions and apply it to the list of number from one to seven, we can see the height of all tree nodes. By applying Node 4 has height 0 Node 5 has height 0 Node 2 has height 1 Node 6 has height 0 Node 7 has height 0 Node 3 has height 1 and Node 1 has height 2. By applying compute_and_print_heights, we could see that Node 4 has height 0 Node 5 has height 0 Node 2 has height 1 Node 6 has height 0 Node 7 has height 0 Node 3 has height 1 and Node 1 has height 2.
Exercise 3 To reimplement the SortedPriorityQueue using Python list array, we first need to initialize underscore data in the init method as an empty list and change add, min and remove_min method.
Reimplementation of add method: Create a new instance of the _Item class using the provided key and value. Loop through the index (i) and the item (item) at each position in the list. Compare the newly created item newest with the current item in the list Insert the new item at the position (i). This maintains the sorted order of the list. Break out of the loop after having found the correct position and completed the insertion. Append the new item to the end if no position is found after the loop
Reimplementation of min method: Raise an exception if empty if the priority queue is empty. Return the smallest item at the front of the list. Raise an exception if empty if the priority queue is empty. Return the smallest item at the front of the list
Reimplementation of remove_min method: Raise an exception if empty if the priority queue is empty. Remove the smallest item from the front of the list. Return the key-value pair of the removed item. The time complexity of the remove_min method is O(1) for removing the minimum element from the priority queue. This is because the method simply removes the first element from the list, which can be done in constant time. The space complexity of the remove_min method is O(1) as well. This is because the method only removes one element from the list and does not create any additional data structures that grow with the input size.
